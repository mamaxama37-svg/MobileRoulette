<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Live Roulette Analyzer</title>
<style>
body { background:#000; color:#fff; font-family:sans-serif; margin:0; text-align:center; }
header { background:#111; padding:12px; font-size:1.3em; }
#videoContainer { position:relative; margin:10px auto; width:100%; max-width:400px; }
video { width:100%; border:2px solid #fff; }
canvas { position:absolute; top:0; left:0; width:100%; height:100%; }
#results { margin:10px; }
#prediction { font-size:1.2em; margin-top:10px; }
.numberBox { position:absolute; padding:2px 4px; border-radius:3px; font-weight:bold; color:#fff; background:rgba(0,0,0,0.5); pointer-events:none; }
.hot { color:#f00; } .neighbor { color:#ff0; }
</style>
</head>
<body>

<header>Smart Live Roulette Analyzer</header>

<div id="videoContainer">
  <video id="rouletteVideo" autoplay playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<div id="results">
  <div id="last100">Last 100 Numbers: --</div>
  <div id="prediction">Prediction: --</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script>
/* ===== WHEEL MODEL ===== */
const wheel=[0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
let last100Numbers = [];
let prediction = {number:null, neighbor:null};

/* ===== CAMERA SETUP ===== */
const video=document.getElementById("rouletteVideo");
const overlay=document.getElementById("overlay");
const ctx=overlay.getContext("2d");

async function initCamera(){
  try{
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:false});
    video.srcObject=stream;
    video.onloadedmetadata=()=>{ overlay.width=video.videoWidth; overlay.height=video.videoHeight; }
  }catch(err){ alert("Camera init failed: "+err); }
}
initCamera();

/* ===== OCR & LIVE DETECTION ===== */
async function analyzeFrame(){
  if(video.readyState<2){ requestAnimationFrame(analyzeFrame); return; }

  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.drawImage(video,0,0,overlay.width,overlay.height);

  const x=0, y=0, w=overlay.width, h=overlay.height;
  const imageData=ctx.getImageData(x,y,w,h);

  try{
    const result=await Tesseract.recognize(imageData,'eng',{logger:m=>{}});
    let nums=result.data.text.match(/\b([0-9]|[1-2][0-9]|3[0-6])\b/g);
    if(nums && nums.length>0){
      last100Numbers = nums.map(Number).slice(-100);
      document.getElementById("last100").innerText="Last 100 Numbers: "+last100Numbers.join(",");

      // Highlight numbers on screen
      result.data.words.forEach(word=>{
        const val = parseInt(word.text);
        if(!isNaN(val)){
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(word.bbox.x0, word.bbox.y0, word.bbox.x1-word.bbox.x0, word.bbox.y1-word.bbox.y0);
          ctx.fillStyle="#fff"; ctx.font="14px sans-serif";
          ctx.fillText(val, word.bbox.x0+2, word.bbox.y1-2);
        }
      });

      runSmartPrediction();
    }
  }catch(e){ console.log("OCR error:",e); }

  requestAnimationFrame(analyzeFrame);
}
analyzeFrame();

/* ===== SMART MATHEMATICAL PREDICTION ===== */
function runSmartPrediction(){
  if(last100Numbers.length===0) return;

  // Frequency calculation
  const freq = Array(37).fill(0);
  last100Numbers.forEach(n=>{
    freq[n]++;
  });

  // Momentum weight: last 10 numbers
  const last10 = last100Numbers.slice(-10);
  last10.forEach(n=>{ freq[n]+=2; });

  // Neighbor boost
  const scores = Array(37).fill(0);
  wheel.forEach((num,idx)=>{
    const neighbors = [wheel[(idx-1+wheel.length)%37], wheel[(idx+1)%wheel.length]];
    scores[num] = freq[num] + neighbors.reduce((sum,n)=>sum+freq[n]*0.5,0);
  });

  const maxScore=Math.max(...scores);
  const topNumbers=[];
  scores.forEach((s,i)=>{ if(s===maxScore) topNumbers.push(i); });

  const nextNumber=topNumbers[Math.floor(Math.random()*topNumbers.length)];

  // Best neighbor
  const idx=wheel.indexOf(nextNumber);
  const neighbors=[wheel[(idx-1+wheel.length)%37], wheel[(idx+1)%wheel.length]];
  const neighborScore=neighbors.map(n=>scores[n]);
  const bestNeighbor=neighbors[neighborScore[0]>=neighborScore[1]?0:1];

  prediction.number=nextNumber;
  prediction.neighbor=bestNeighbor;

  document.getElementById("prediction").innerHTML=
    `<b>Next Number Prediction:</b> <span class="hot">${nextNumber}</span> | <b>Neighbor:</b> <span class="neighbor">${bestNeighbor}</span>`;
}
</script>
</body>
</html>
