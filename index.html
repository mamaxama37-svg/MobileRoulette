<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mobile Roulette Analyzer - Optimized Smooth</title>
<style>
body {margin:0; font-family:Arial; background:#000; color:#fff; text-align:center;}
header{background:#111;padding:10px;font-size:1.3em;}
#videoContainer{position:relative;width:100%;max-width:600px;margin:auto;}
canvas{width:100%;height:auto;border:2px solid #fff;}
.statBox{background:#222;padding:8px;margin:4px;border-radius:5px;}
#stats{margin-top:10px;font-size:0.9em;}
</style>
</head>
<body>

<header>Mobile Roulette Analyzer</header>

<div id="videoContainer">
  <video id="cameraVideo" autoplay playsinline style="display:none;"></video>
  <canvas id="overlay"></canvas>
</div>

<div id="stats">
  <div class="statBox" id="ballSpeed">Ball Speed: -- rad/s</div>
  <div class="statBox" id="lastNumbers">Last Numbers: --</div>
  <div class="statBox" id="prediction">Next Prediction: --</div>
  <div class="statBox" id="topSectors">Top 3 Sectors: --</div>
  <div class="statBox" id="topNeighbors">Top 5 Neighbors: --</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script>
const wheel=[0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,
30,8,23,10,5,24,16,33,1,20,14,31,9,
22,18,29,7,28,12,35,3,26];

let history=[], lastNumber=-1;
let prevAngle=null, prevTime=null, currentSpeed=0;
let topSectors=[], topNeighbors=[];

const video=document.getElementById('cameraVideo');
const canvas=document.getElementById('overlay');
const ctx=canvas.getContext('2d');

// Processing offscreen canvas
const procCanvas=document.createElement('canvas');
const procCtx=procCanvas.getContext('2d');

// Back camera, low resolution for performance
navigator.mediaDevices.getUserMedia({
  video:{facingMode:"environment", width:320, height:240}
}).then(stream => video.srcObject = stream)
.catch(e=>alert("Camera access denied or unavailable"));

// Detect wheel center
function detectWheel(frameCtx){
  const w=frameCtx.canvas.width;
  const h=frameCtx.canvas.height;
  return {cx:w/2, cy:h/2, radius:Math.min(w,h)/3};
}

// Detect ball using sampling every 4 pixels
function detectBall(frameCtx,wheelCenter){
  const w=frameCtx.canvas.width;
  const h=frameCtx.canvas.height;
  const img=frameCtx.getImageData(0,0,w,h);
  let brightest={x:0,y:0,max:0};
  for(let i=0;i<img.data.length;i+=16){
    const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
    const brightness=r+g+b;
    const px=(i/4)%w, py=Math.floor(i/4/w);
    const dx=px-wheelCenter.cx, dy=py-wheelCenter.cy;
    const dist=Math.sqrt(dx*dx+dy*dy);
    if(dist>wheelCenter.radius*0.6 && dist<wheelCenter.radius*1.05 && brightness>brightest.max){
      brightest.max=brightness; brightest.x=px; brightest.y=py;
    }
  }
  return brightest.max>200?{x:brightest.x,y:brightest.y}:null;
}

// Track ball motion
function trackBall(ball,wheelCenter){
  const now=performance.now();
  const angle=Math.atan2(ball.y-wheelCenter.cy, ball.x-wheelCenter.cx);
  if(prevAngle!==null){
    const dt=(now-prevTime)/1000;
    currentSpeed=(angle-prevAngle)/dt;
  }
  prevAngle=angle; prevTime=now;
}

// OCR detection region
function getNumberRegion(wheelCenter){
  const size=wheelCenter.radius*0.5;
  return {x:wheelCenter.cx-size, y:wheelCenter.cy-size, w:size*2, h:size};
}

// OCR every 3 seconds
let lastOCR=0;
const OCR_INTERVAL=3000;

async function detectNumber(region){
  const now=performance.now();
  if(now-lastOCR<OCR_INTERVAL) return;
  lastOCR=now;
  // draw to processing canvas
  procCanvas.width=region.w;
  procCanvas.height=region.h;
  procCtx.drawImage(canvas,region.x,region.y,region.w,region.h,0,0,region.w,region.h);
  try{
    const result=await Tesseract.recognize(procCanvas,'eng');
    const num=parseInt(result.data.text.replace(/\D/g,''));
    if(!isNaN(num)&&num>=0&&num<=36 && num!==lastNumber){
      lastNumber=num;
      history.push(num);
      if(history.length>100) history.shift();
      updatePredictions();
    }
  }catch(e){console.log("OCR failed",e);}
}

// Predictions
function updatePredictions(){
  if(history.length===0) return;
  const counts=Array(37).fill(0);
  history.forEach(n=>counts[n]+=1);
  const sorted=counts.map((v,i)=>({num:i,count:v})).sort((a,b)=>b.count-a.count);
  
  topSectors=sorted.slice(0,3).map(x=>x.num);
  const neighborSet=new Set();
  for(let n of topSectors){
    const idx=wheel.indexOf(n);
    [-2,-1,1,2].forEach(off=>{
      const x=wheel[(idx+off+37)%37];
      if(neighborSet.size<5 && !topSectors.includes(x)) neighborSet.add(x);
    });
  }
  topNeighbors=Array.from(neighborSet);
  
  document.getElementById('ballSpeed').innerText="Ball Speed: "+currentSpeed.toFixed(2)+" rad/s";
  document.getElementById('lastNumbers').innerText="Last Numbers: "+history.slice(-10).join(", ");
  document.getElementById('prediction').innerText="Next Prediction: "+sorted[0].num;
  document.getElementById('topSectors').innerText="Top 3 Sectors: "+topSectors.join(", ");
  document.getElementById('topNeighbors').innerText="Top 5 Neighbors: "+topNeighbors.join(", ");
}

// Main frame loop
async function analyzeFrame(){
  canvas.width=video.videoWidth;
  canvas.height=video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  const wheelCenter=detectWheel(ctx);
  const ball=detectBall(ctx,wheelCenter);
  if(ball) trackBall(ball,wheelCenter);

  const region=getNumberRegion(wheelCenter);
  await detectNumber(region);

  requestAnimationFrame(analyzeFrame);
}

video.onloadedmetadata=()=>analyzeFrame();
</script>

</body>
</html>
